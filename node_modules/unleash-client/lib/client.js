"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var variant_1 = require("./variant");
var events_2 = require("./events");
var UnleashClient = /** @class */ (function (_super) {
    __extends(UnleashClient, _super);
    function UnleashClient(repository, strategies) {
        var _this = _super.call(this) || this;
        _this.repository = repository;
        _this.strategies = strategies || [];
        _this.warned = {};
        _this.strategies.forEach(function (strategy) {
            if (!strategy ||
                !strategy.name ||
                typeof strategy.name !== 'string' ||
                !strategy.isEnabled ||
                typeof strategy.isEnabled !== 'function') {
                throw new Error('Invalid strategy data / interface');
            }
        });
        return _this;
    }
    UnleashClient.prototype.getStrategy = function (name) {
        return this.strategies.find(function (strategy) { return strategy.name === name; });
    };
    UnleashClient.prototype.warnOnce = function (missingStrategy, name, strategies) {
        if (!this.warned[missingStrategy + name]) {
            this.warned[missingStrategy + name] = true;
            this.emit(events_2.UnleashEvents.Warn, "Missing strategy \"".concat(missingStrategy, "\" for toggle \"").concat(name, "\". Ensure that \"").concat(strategies
                .map(function (_a) {
                var n = _a.name;
                return n;
            })
                .join(', '), "\" are supported before using this toggle"));
        }
    };
    UnleashClient.prototype.isEnabled = function (name, context, fallback) {
        var feature = this.repository.getToggle(name);
        var enabled = this.isFeatureEnabled(feature, context, fallback);
        this.emit(events_2.UnleashEvents.Impression, (0, events_2.createImpressionEvent)({
            featureName: name,
            context: context,
            enabled: enabled,
            eventType: 'isEnabled'
        }));
        return enabled;
    };
    UnleashClient.prototype.isFeatureEnabled = function (feature, context, fallback) {
        var _this = this;
        if (!feature) {
            return fallback();
        }
        if (!feature || !feature.enabled) {
            return false;
        }
        if (!Array.isArray(feature.strategies)) {
            var msg = "Malformed feature, strategies not an array, is a ".concat(typeof feature.strategies);
            this.emit(events_2.UnleashEvents.Error, new Error(msg));
            return false;
        }
        if (feature.strategies.length === 0) {
            return feature.enabled;
        }
        return (feature.strategies.length > 0 &&
            feature.strategies.some(function (strategySelector) {
                var strategy = _this.getStrategy(strategySelector.name);
                if (!strategy) {
                    _this.warnOnce(strategySelector.name, feature.name, feature.strategies);
                    return false;
                }
                var constraints = _this.yieldConstraintsFor(strategySelector);
                return strategy.isEnabledWithConstraints(strategySelector.parameters, context, constraints);
            }));
    };
    UnleashClient.prototype.yieldConstraintsFor = function (strategy) {
        var segments;
        var _this = this;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!strategy.constraints) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(strategy.constraints)];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    segments = (_a = strategy.segments) === null || _a === void 0 ? void 0 : _a.map(function (segmentId) { return _this.repository.getSegment(segmentId); });
                    if (!segments) {
                        return [2 /*return*/];
                    }
                    return [5 /*yield**/, __values(this.yieldSegmentConstraints(segments))];
                case 3:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    };
    UnleashClient.prototype.yieldSegmentConstraints = function (segments) {
        var segments_1, segments_1_1, segment, _a, _b, constraint, e_1_1, e_2_1;
        var e_2, _c, e_1, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _e.trys.push([0, 14, 15, 16]);
                    segments_1 = __values(segments), segments_1_1 = segments_1.next();
                    _e.label = 1;
                case 1:
                    if (!!segments_1_1.done) return [3 /*break*/, 13];
                    segment = segments_1_1.value;
                    if (!segment) return [3 /*break*/, 10];
                    _e.label = 2;
                case 2:
                    _e.trys.push([2, 7, 8, 9]);
                    _a = (e_1 = void 0, __values(segment === null || segment === void 0 ? void 0 : segment.constraints)), _b = _a.next();
                    _e.label = 3;
                case 3:
                    if (!!_b.done) return [3 /*break*/, 6];
                    constraint = _b.value;
                    return [4 /*yield*/, constraint];
                case 4:
                    _e.sent();
                    _e.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: return [3 /*break*/, 12];
                case 10: return [4 /*yield*/, undefined];
                case 11:
                    _e.sent();
                    _e.label = 12;
                case 12:
                    segments_1_1 = segments_1.next();
                    return [3 /*break*/, 1];
                case 13: return [3 /*break*/, 16];
                case 14:
                    e_2_1 = _e.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 16];
                case 15:
                    try {
                        if (segments_1_1 && !segments_1_1.done && (_c = segments_1.return)) _c.call(segments_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 16: return [2 /*return*/];
            }
        });
    };
    UnleashClient.prototype.getVariant = function (name, context, fallbackVariant) {
        var variant = this.resolveVariant(name, context, true, fallbackVariant);
        this.emit(events_2.UnleashEvents.Impression, (0, events_2.createImpressionEvent)({
            featureName: name,
            context: context,
            enabled: variant.enabled,
            eventType: 'getVariant',
            variant: variant.name,
        }));
        return variant;
    };
    // This function is intended to close an issue in the proxy where feature enabled
    // state gets checked twice when resolving a variant with random stickiness and
    // gradual rollout. This is not intended for general use, prefer getVariant instead
    UnleashClient.prototype.forceGetVariant = function (name, context, fallbackVariant) {
        return this.resolveVariant(name, context, false, fallbackVariant);
    };
    UnleashClient.prototype.resolveVariant = function (name, context, checkToggle, fallbackVariant) {
        var fallback = fallbackVariant || (0, variant_1.getDefaultVariant)();
        var feature = this.repository.getToggle(name);
        if (typeof feature === 'undefined' ||
            !feature.variants ||
            !Array.isArray(feature.variants) ||
            feature.variants.length === 0) {
            return fallback;
        }
        var enabled = true;
        if (checkToggle) {
            enabled = this.isFeatureEnabled(feature, context, function () {
                return fallbackVariant ? fallbackVariant.enabled : false;
            });
            if (!enabled) {
                return fallback;
            }
        }
        var variant = (0, variant_1.selectVariant)(feature, context);
        if (variant === null) {
            return fallback;
        }
        return {
            name: variant.name,
            payload: variant.payload,
            enabled: !checkToggle || enabled,
        };
    };
    return UnleashClient;
}(events_1.EventEmitter));
exports.default = UnleashClient;
//# sourceMappingURL=client.js.map