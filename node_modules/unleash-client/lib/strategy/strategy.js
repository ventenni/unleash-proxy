"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Strategy = exports.Operator = void 0;
var semver_1 = require("semver");
var helpers_1 = require("../helpers");
var Operator;
(function (Operator) {
    Operator["IN"] = "IN";
    Operator["NOT_IN"] = "NOT_IN";
    Operator["STR_ENDS_WITH"] = "STR_ENDS_WITH";
    Operator["STR_STARTS_WITH"] = "STR_STARTS_WITH";
    Operator["STR_CONTAINS"] = "STR_CONTAINS";
    Operator["NUM_EQ"] = "NUM_EQ";
    Operator["NUM_GT"] = "NUM_GT";
    Operator["NUM_GTE"] = "NUM_GTE";
    Operator["NUM_LT"] = "NUM_LT";
    Operator["NUM_LTE"] = "NUM_LTE";
    Operator["DATE_AFTER"] = "DATE_AFTER";
    Operator["DATE_BEFORE"] = "DATE_BEFORE";
    Operator["SEMVER_EQ"] = "SEMVER_EQ";
    Operator["SEMVER_GT"] = "SEMVER_GT";
    Operator["SEMVER_LT"] = "SEMVER_LT";
})(Operator = exports.Operator || (exports.Operator = {}));
var cleanValues = function (values) { return values.filter(function (v) { return !!v; }).map(function (v) { return v.trim(); }); };
var isStrictSemver = function (version) { return (0, semver_1.clean)(version) === version; };
var InOperator = function (constraint, context) {
    var field = constraint.contextName;
    var values = cleanValues(constraint.values);
    var contextValue = (0, helpers_1.resolveContextValue)(context, field);
    var isIn = values.some(function (val) { return val === contextValue; });
    return constraint.operator === Operator.IN ? isIn : !isIn;
};
var StringOperator = function (constraint, context) {
    var contextName = constraint.contextName, operator = constraint.operator, caseInsensitive = constraint.caseInsensitive;
    var values = cleanValues(constraint.values);
    var contextValue = (0, helpers_1.resolveContextValue)(context, contextName);
    if (caseInsensitive) {
        values = values.map(function (v) { return v.toLocaleLowerCase(); });
        contextValue = contextValue === null || contextValue === void 0 ? void 0 : contextValue.toLocaleLowerCase();
    }
    if (typeof contextValue !== 'string') {
        return false;
    }
    if (operator === Operator.STR_STARTS_WITH) {
        return values.some(function (val) { return contextValue === null || contextValue === void 0 ? void 0 : contextValue.startsWith(val); });
    }
    if (operator === Operator.STR_ENDS_WITH) {
        return values.some(function (val) { return contextValue === null || contextValue === void 0 ? void 0 : contextValue.endsWith(val); });
    }
    if (operator === Operator.STR_CONTAINS) {
        return values.some(function (val) { return contextValue === null || contextValue === void 0 ? void 0 : contextValue.includes(val); });
    }
    return false;
};
var SemverOperator = function (constraint, context) {
    var contextName = constraint.contextName, operator = constraint.operator;
    var value = constraint.value;
    var contextValue = (0, helpers_1.resolveContextValue)(context, contextName);
    if (!contextValue || !isStrictSemver(contextValue)) {
        return false;
    }
    try {
        if (operator === Operator.SEMVER_EQ) {
            return (0, semver_1.eq)(contextValue, value);
        }
        if (operator === Operator.SEMVER_LT) {
            return (0, semver_1.lt)(contextValue, value);
        }
        if (operator === Operator.SEMVER_GT) {
            return (0, semver_1.gt)(contextValue, value);
        }
    }
    catch (e) {
        return false;
    }
    return false;
};
var DateOperator = function (constraint, context) {
    var operator = constraint.operator;
    var value = new Date(constraint.value);
    var currentTime = context.currentTime ? new Date(context.currentTime) : new Date();
    if (operator === Operator.DATE_AFTER) {
        return currentTime > value;
    }
    if (operator === Operator.DATE_BEFORE) {
        return currentTime < value;
    }
    return false;
};
var NumberOperator = function (constraint, context) {
    var field = constraint.contextName;
    var operator = constraint.operator;
    var value = Number(constraint.value);
    var contextValue = Number((0, helpers_1.resolveContextValue)(context, field));
    if (Number.isNaN(value) || Number.isNaN(contextValue)) {
        return false;
    }
    if (operator === Operator.NUM_EQ) {
        return contextValue === value;
    }
    if (operator === Operator.NUM_GT) {
        return contextValue > value;
    }
    if (operator === Operator.NUM_GTE) {
        return contextValue >= value;
    }
    if (operator === Operator.NUM_LT) {
        return contextValue < value;
    }
    if (operator === Operator.NUM_LTE) {
        return contextValue <= value;
    }
    return false;
};
var operators = new Map();
operators.set(Operator.IN, InOperator);
operators.set(Operator.NOT_IN, InOperator);
operators.set(Operator.STR_STARTS_WITH, StringOperator);
operators.set(Operator.STR_ENDS_WITH, StringOperator);
operators.set(Operator.STR_CONTAINS, StringOperator);
operators.set(Operator.NUM_EQ, NumberOperator);
operators.set(Operator.NUM_LT, NumberOperator);
operators.set(Operator.NUM_LTE, NumberOperator);
operators.set(Operator.NUM_GT, NumberOperator);
operators.set(Operator.NUM_GTE, NumberOperator);
operators.set(Operator.DATE_AFTER, DateOperator);
operators.set(Operator.DATE_BEFORE, DateOperator);
operators.set(Operator.SEMVER_EQ, SemverOperator);
operators.set(Operator.SEMVER_GT, SemverOperator);
operators.set(Operator.SEMVER_LT, SemverOperator);
var Strategy = /** @class */ (function () {
    function Strategy(name, returnValue) {
        if (returnValue === void 0) { returnValue = false; }
        this.name = name || 'unknown';
        this.returnValue = returnValue;
    }
    Strategy.prototype.checkConstraint = function (constraint, context) {
        var evaluator = operators.get(constraint.operator);
        if (!evaluator) {
            return false;
        }
        if (constraint.inverted) {
            return !evaluator(constraint, context);
        }
        return evaluator(constraint, context);
    };
    Strategy.prototype.checkConstraints = function (context, constraints) {
        var e_1, _a;
        if (!constraints) {
            return true;
        }
        try {
            // eslint-disable-next-line no-restricted-syntax
            for (var constraints_1 = __values(constraints), constraints_1_1 = constraints_1.next(); !constraints_1_1.done; constraints_1_1 = constraints_1.next()) {
                var constraint = constraints_1_1.value;
                if (!constraint || !this.checkConstraint(constraint, context)) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (constraints_1_1 && !constraints_1_1.done && (_a = constraints_1.return)) _a.call(constraints_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Strategy.prototype.isEnabled = function (parameters, context) {
        return this.returnValue;
    };
    Strategy.prototype.isEnabledWithConstraints = function (parameters, context, constraints) {
        return this.checkConstraints(context, constraints) && this.isEnabled(parameters, context);
    };
    return Strategy;
}());
exports.Strategy = Strategy;
//# sourceMappingURL=strategy.js.map