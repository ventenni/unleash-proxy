"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const create_context_1 = require("./create-context");
const features_response_1 = require("./openapi/spec/features-response");
const common_responses_1 = require("./openapi/common-responses");
const api_request_response_1 = require("./openapi/spec/api-request-response");
const prometheus_request_response_1 = require("./openapi/spec/prometheus-request-response");
const lookup_toggles_request_1 = require("./openapi/spec/lookup-toggles-request");
const register_metrics_request_1 = require("./openapi/spec/register-metrics-request");
const register_client_request_1 = require("./openapi/spec/register-client-request");
const openapi_helpers_1 = require("./openapi/openapi-helpers");
class UnleashProxy {
    constructor(client, config, openApiService) {
        this.ready = false;
        this.logger = config.logger;
        this.clientKeys = config.clientKeys;
        this.serverSideTokens = config.serverSideSdkConfig
            ? config.serverSideSdkConfig.tokens
            : [];
        this.clientKeysHeaderName = config.clientKeysHeaderName;
        this.client = client;
        if (client.isReady()) {
            this.setReady();
        }
        this.client.on('ready', () => {
            this.setReady();
        });
        const router = (0, express_1.Router)();
        this.middleware = router;
        // Routes
        router.get('', openApiService.validPath({
            parameters: [
                ...(0, openapi_helpers_1.createRequestParameters)({
                    appName: "Your application's name",
                    userId: "The current user's ID",
                    sessionId: "The current session's ID",
                    remoteAddress: "Your application's IP address",
                }),
                ...(0, openapi_helpers_1.createDeepObjectRequestParameters)({
                    properties: {
                        description: 'Additional (custom) context fields',
                        example: {
                            region: 'Africa',
                            betaTester: 'true',
                        },
                    },
                }),
            ],
            responses: {
                ...(0, common_responses_1.standardResponses)(401, 500, 503),
                200: features_response_1.featuresResponse,
            },
            description: 'This endpoint returns the list of feature toggles that the proxy evaluates to enabled for the given context. Context values are provided as query parameters.',
            summary: 'Retrieve enabled feature toggles for the provided context.',
            tags: ['Proxy client'],
        }), this.getEnabledToggles.bind(this));
        router.post('', openApiService.validPath({
            requestBody: lookup_toggles_request_1.lookupTogglesRequest,
            responses: {
                ...(0, common_responses_1.standardResponses)(400, 401, 500, 503),
                200: features_response_1.featuresResponse,
            },
            description: 'This endpoint accepts a JSON object with `context` and `toggles` properties. The Proxy will use the provided context values and evaluate the toggles provided in the `toggle` property. It returns the toggles that evaluate to false. As such, the list it returns is always a subset of the toggles you provide it.',
            summary: 'Which of the provided toggles are enabled given the provided context?',
            tags: ['Proxy client'],
        }), this.lookupToggles.bind(this));
        router.get('/client/features', openApiService.validPath({
            responses: {
                ...(0, common_responses_1.standardResponses)(401, 503),
                200: api_request_response_1.apiRequestResponse,
            },
            description: "Returns the toggle configuration from the proxy's internal Unleash SDK. Use this to bootstrap other proxies and server-side SDKs. Requires you to provide one of the proxy's configured `serverSideTokens` for authorization.",
            summary: "Retrieve the proxy's current toggle configuration (as consumed by the internal client).",
            tags: ['Server-side client'],
        }), this.unleashApi.bind(this));
        router.post('/client/metrics', openApiService.validPath({
            requestBody: register_metrics_request_1.registerMetricsRequest,
            responses: (0, common_responses_1.standardResponses)(200, 400, 401),
            description: "This endpoint lets you register usage metrics with Unleash. Accepts either one of the proxy's configured `serverSideTokens` or one of its `clientKeys` for authorization.",
            summary: 'Send usage metrics to Unleash.',
            tags: ['Operational', 'Server-side client'],
        }), this.registerMetrics.bind(this));
        router.post('/client/register', openApiService.validPath({
            requestBody: register_client_request_1.registerClientRequest,
            responses: (0, common_responses_1.standardResponses)(200, 400, 401),
            description: "This endpoint lets you register application with Unleash. Accepts either one of the proxy's configured `serverSideTokens` or one of its `clientKeys` for authorization.",
            summary: 'Register clients with Unleash.',
            tags: ['Operational', 'Server-side client'],
        }), this.registerClient.bind(this));
        router.get('/health', openApiService.validPath({
            security: [],
            responses: {
                ...(0, common_responses_1.standardResponses)(200, 503),
            },
            description: 'Returns a 200 OK if the proxy is ready to receive requests. Otherwise returns a 503 NOT READY.',
            summary: 'Check whether the proxy is ready to serve requests yet.',
            tags: ['Operational'],
        }), this.health.bind(this));
        router.get('/internal-backstage/prometheus', openApiService.validPath({
            security: [],
            responses: {
                ...(0, common_responses_1.standardResponses)(503),
                200: prometheus_request_response_1.prometheusRequestResponse,
            },
            description: 'Returns a 200 and valid Prometheus text syntax if the proxy is ready to receive requests. Otherwise returns a 503 NOT READY.',
            summary: 'Check whether the proxy is up and running',
            tags: ['Operational'],
        }), this.prometheus.bind(this));
    }
    setReady() {
        this.ready = true;
        this.logger.info('Successfully synchronized with Unleash API. Proxy is now ready to receive traffic.');
    }
    // kept for backward compatibility
    setProxySecrets(clientKeys) {
        this.setClientKeys(clientKeys);
    }
    setClientKeys(clientKeys) {
        this.clientKeys = clientKeys;
    }
    getEnabledToggles(req, res) {
        const apiToken = req.header(this.clientKeysHeaderName);
        if (!this.ready) {
            res.status(503).send(common_responses_1.NOT_READY_MSG);
        }
        else if (!apiToken || !this.clientKeys.includes(apiToken)) {
            res.sendStatus(401);
        }
        else {
            const { query } = req;
            query.remoteAddress = query.remoteAddress || req.ip;
            const context = (0, create_context_1.createContext)(query);
            const toggles = this.client.getEnabledToggles(context);
            res.set('Cache-control', 'public, max-age=2');
            res.send({ toggles });
        }
    }
    lookupToggles(req, res) {
        const clientToken = req.header(this.clientKeysHeaderName);
        if (!this.ready) {
            res.status(503).send(common_responses_1.NOT_READY_MSG);
        }
        else if (!clientToken || !this.clientKeys.includes(clientToken)) {
            res.sendStatus(401);
        }
        else {
            const { context = {}, toggles: toggleNames = [] } = req.body;
            const toggles = this.client.getDefinedToggles(toggleNames, context);
            res.send({ toggles });
        }
    }
    health(_, res) {
        if (!this.ready) {
            res.status(503).send(common_responses_1.NOT_READY_MSG);
        }
        else {
            res.send('ok');
        }
    }
    prometheus(_, res) {
        if (!this.ready) {
            res.status(503).send(common_responses_1.NOT_READY_MSG);
        }
        else {
            const prometheusResponse = '# HELP unleash_proxy_up Indication that the service is up. \n' +
                '# TYPE unleash_proxy_up counter\n' +
                'unleash_proxy_up 1\n';
            res.set('Content-type', 'text/plain');
            res.send(prometheusResponse);
        }
    }
    registerMetrics(req, res) {
        const token = req.header(this.clientKeysHeaderName);
        const validTokens = [...this.clientKeys, ...this.serverSideTokens];
        if (token && validTokens.includes(token)) {
            this.client.registerMetrics(req.body);
            res.sendStatus(200);
        }
        else {
            res.sendStatus(401);
        }
    }
    registerClient(req, res) {
        const token = req.header(this.clientKeysHeaderName);
        const validTokens = [...this.clientKeys, ...this.serverSideTokens];
        if (token && validTokens.includes(token)) {
            this.logger.debug('Client registration is not supported yet.');
            res.sendStatus(200);
        }
        else {
            res.sendStatus(401);
        }
    }
    unleashApi(req, res) {
        const apiToken = req.header(this.clientKeysHeaderName);
        if (!this.ready) {
            res.status(503).send(common_responses_1.NOT_READY_MSG);
        }
        else if (apiToken && this.serverSideTokens.includes(apiToken)) {
            const features = this.client.getFeatureToggleDefinitions();
            res.set('Cache-control', 'public, max-age=2');
            res.send({ version: 2, features });
        }
        else {
            res.sendStatus(401);
        }
    }
}
exports.default = UnleashProxy;
//# sourceMappingURL=unleash-proxy.js.map